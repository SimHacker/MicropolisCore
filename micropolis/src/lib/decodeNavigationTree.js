// micropolis/src/lib/decodeNavigationTree.js\n// Reads navigationTreeData.js, decodes HTML entities in descriptions,\n// and prints the final siteStructure array as JavaScript code.\n\nimport { siteStructure as encodedStructure } from \'./navigationTreeData.js\';\n\n// Basic HTML entity decoder (handles &#x...; format)\nfunction decodeHtmlEntities(text) {\n    if (!text) return text;\n    // Create a temporary textarea element to leverage the browser\'s/DOM\'s decoder\n    // This is a trick often used in browser environments, but might need adjustment\n    // in a pure Node.js environment if a DOM isn\'t available.\n    // For Node.js, a library like \'he\' would be more robust.\n    // However, let\'s try the DOM trick first as it\'s simpler.\n    try {\n        // This part assumes a DOM-like environment or polyfill might be needed\n        if (typeof document !== \'undefined\') {\n            const textarea = document.createElement(\'textarea\');\n            textarea.innerHTML = text;\n            return textarea.value;\n        } else {\n            // Fallback for pure Node.js - requires \'he\' library: npm install he\n            // Uncomment the next two lines and comment out the DOM part if using \'he\'\n            // import he from \'he\';\n            // return he.decode(text);\n\n            // Simple fallback if no DOM and \'he\' not installed (might miss some entities)\n             return text.replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => {\n                 return String.fromCodePoint(parseInt(hex, 16));\n             });\n        }\n    } catch (e) {\n        console.error(\"Error decoding HTML entities:\", e);\n        return text; // Return original text on error\n    }\n}\n\n// Recursive function to decode descriptions in the structure\nfunction decodeDescriptions(nodes) {\n    if (!nodes) return nodes;\n    return nodes.map(node => {\n        const { comment, ...restOfNode } = node; // Destructure to exclude comment\n        const newNode = { ...restOfNode }; // Shallow copy the rest\n        if (newNode.description) {\n            newNode.description = decodeHtmlEntities(newNode.description);\n        }\n        if (newNode.children) {\n            newNode.children = decodeDescriptions(newNode.children); // Recurse\n        }\n        return newNode;\n    });\n}\n\nconst decodedStructure = decodeDescriptions(encodedStructure);\n\n// Output the final JavaScript module content\nconsole.log(`// micropolis/src/lib/navigationTree.js`);\nconsole.log(`// Generated by decodeNavigationTree.js - DO NOT EDIT MANUALLY`);\nconsole.log(`// Defines the entire site structure with decoded emojis.`);\nconsole.log(`\nexport const siteStructure = ${JSON.stringify(decodedStructure, null, 4)};\n`);\n\n// --- Add the helper functions back --- \n// (Copied from the original navigationTree.js, assuming they don't need modification)\n\nconsole.log(`\n// --- Helper Functions --- \n\n// Map for efficient URL lookup: Map<string, { node: object, fullPath: Array<object> }>\nconst urlMapWithPath = new Map();\n// Array for nodes with matchUrlPrefix = true: Array<{ node: object, fullPath: Array<object> }>\nconst prefixNodesWithPath = [];\n\n/**\n * Builds the urlMapWithPath and prefixNodesWithPath array from the siteStructure.\n * Stores the node and its full path from the root.\n * Should be called once at application startup.\n * @param {Array<object>} nodes - The siteStructure array (or children array).\n * @param {Array<object>} currentPath - The array of ancestor nodes leading to this level.\n */\nfunction buildLookupsWithPath(nodes, currentPath = []) {\n    if (!nodes) return;\n    nodes.forEach(node => {\n        // Define the full path for *this* node\n        const nodeFullPath = [...currentPath, node];\n\n        if (node.url) {\n            const nodeData = { node: node, fullPath: nodeFullPath }; // Store node and its full path\n            if (urlMapWithPath.has(node.url)) {\n                console.warn(\`Duplicate URL detected in siteStructure: \${node.url}\`);\n            }\n            urlMapWithPath.set(node.url, nodeData);\n\n            // Add to prefix nodes if applicable\n            if (node.matchUrlPrefix === true) {\n                prefixNodesWithPath.push(nodeData);\n            }\n        }\n        // Recurse for children, passing the *new* full path\n        if (node.children) {\n            buildLookupsWithPath(node.children, nodeFullPath); // Pass path including current node\n        }\n    });\n}\n\n/**\n * Finds a node and its ancestors in the site structure based on the requested URL.\n * Prioritizes exact match, then falls back to the longest prefix match\n * for nodes marked with \`matchUrlPrefix: true\`.\n * Requires \`buildLookupsWithPath\` to have been called first.\n *\n * @param {string} requestedUrl - The URL path to search for (e.g., \'/\', \'/pages/about/will-wright\').\n * @returns {{ node: object, fullPath: Array<object> } | null} The found node data including the full path, or null.\n */\nexport function findNodeByUrl(requestedUrl) {\n    // 1. Prioritize Exact Match\n    const exactMatchData = urlMapWithPath.get(requestedUrl);\n    if (exactMatchData) {\n        return exactMatchData;\n    }\n\n    // 2. Find Best Prefix Match (if no exact match)\n    let bestPrefixMatchData = null;\n    // Iterate through pre-sorted prefixNodes (longest URL first)\n    for (const prefixData of prefixNodesWithPath) {\n        const node = prefixData.node; // Get the node from the stored data\n        // Check if the requested URL starts with the node\'s prefix URL\n        if (requestedUrl.startsWith(node.url)) {\n             const nextChar = requestedUrl[node.url.length];\n             if (nextChar === undefined || nextChar === \'/\' || nextChar === \'?\' || nextChar === \'#\') {\n                // Since prefixNodesWithPath is sorted longest first, the first match is the best\n                bestPrefixMatchData = prefixData;\n                break;\n             }\n        }\n    }\n\n    return bestPrefixMatchData;\n}\n\n/**\n * Generates an array of URL paths for all navigable, non-excluded pages\n * suitable for SvelteKit\'s prerender entries.\n * Requires \`buildLookupsWithPath\` to have been called first.\n *\n * @returns {Array<string>} An array of URL strings.\n */\nexport function getPrerenderEntries() {\n    const entries = [];\n    // Iterate over the values ( { node, fullPath } ) in the map\n    for (const { node } of urlMapWithPath.values()) {\n        // Prerender pages with content slugs, but NOT the root page now\n        if (node.url !== \'/\' && !node.external && node.contentSlug) { \n           entries.push(node.url);\n        }\n        // Add logic here if Svelte-only pages need explicit prerendering\n    }\n    return entries;\n}\n\n\n// --- Initialize Lookups ---\nbuildLookupsWithPath(siteStructure);\n// Sort prefixNodes by node.url.length descending ONCE after building\nprefixNodesWithPath.sort((a, b) => b.node.url.length - a.node.url.length); \n`);\n 